{"loop_id": 0, "unhandled_api_list": ["java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer)", "java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer)", "java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer)", "java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer)", "java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer)", "java.nio.ByteBuffer.get()"], "num_of_unhandled_api": 6, "unhandled_exception_list": ["Please check If the buffer is read only for java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw IllegalArgumentException.", "Please check If this channel was not opened for reading for java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw NonReadableChannelException.", "Please check If this channel is closed for java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw ClosedChannelException.", "Please check If another thread closes this channel          while the read operation is in progress for java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw AsynchronousCloseException.", "Please check If another thread interrupts the current thread          while the read operation is in progress, thereby          closing the channel and setting the current thread's          interrupt status for java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw ClosedByInterruptException.", "Please check If the buffer's current position is not smaller than its limit for java.nio.ByteBuffer.get() in the code snippet you provided, otherwise throw BufferUnderflowException."], "num_of_unhandled_exception": 6}
{"loop_id": 1, "unhandled_api_list": ["java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer)", "java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer)"], "num_of_unhandled_api": 2, "unhandled_exception_list": ["Please check If the buffer is read only for java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw IllegalArgumentException.", "Please check If this channel was not opened for reading for java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw NonReadableChannelException."], "num_of_unhandled_exception": 2}
{"loop_id": 2, "unhandled_api_list": ["java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer)", "java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer)", "java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer)", "java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer)", "java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer)", "java.nio.ByteBuffer.get()"], "num_of_unhandled_api": 6, "unhandled_exception_list": ["Please check If the buffer is read only for java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw IllegalArgumentException.", "Please check If this channel was not opened for reading for java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw NonReadableChannelException.", "Please check If this channel is closed for java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw ClosedChannelException.", "Please check If another thread closes this channel          while the read operation is in progress for java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw AsynchronousCloseException.", "Please check If another thread interrupts the current thread          while the read operation is in progress, thereby          closing the channel and setting the current thread's          interrupt status for java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw ClosedByInterruptException.", "Please check If the buffer's current position is not smaller than its limit for java.nio.ByteBuffer.get() in the code snippet you provided, otherwise throw BufferUnderflowException."], "num_of_unhandled_exception": 6}
{"loop_id": 3, "unhandled_api_list": ["java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer)", "java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer)"], "num_of_unhandled_api": 2, "unhandled_exception_list": ["Please check If the buffer is read only for java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw IllegalArgumentException.", "Please check If this channel was not opened for reading for java.nio.channels.ReadableByteChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw NonReadableChannelException."], "num_of_unhandled_exception": 2}
{"loop_id": 4, "unhandled_api_list": ["java.nio.channels.FileChannel.read(java.nio.ByteBuffer)", "java.nio.channels.FileChannel.read(java.nio.ByteBuffer)", "java.nio.channels.FileChannel.read(java.nio.ByteBuffer)", "java.nio.channels.SocketChannel.read(java.nio.ByteBuffer)", "java.nio.channels.SocketChannel.read(java.nio.ByteBuffer)", "java.nio.channels.SocketChannel.read(java.nio.ByteBuffer)", "java.nio.channels.SocketChannel.read(java.nio.ByteBuffer)", "java.nio.ByteBuffer.get()"], "num_of_unhandled_api": 8, "unhandled_exception_list": ["Please check If this channel is closed for java.nio.channels.FileChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw ClosedChannelException.", "Please check If another thread closes this channel          while the read operation is in progress for java.nio.channels.FileChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw AsynchronousCloseException.", "Please check If another thread interrupts the current thread          while the read operation is in progress, thereby          closing the channel and setting the current thread's          interrupt status for java.nio.channels.FileChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw ClosedByInterruptException.", "Please check If this channel is not yet connected for java.nio.channels.SocketChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw NotYetConnectedException.", "Please check If this channel is closed for java.nio.channels.SocketChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw ClosedChannelException.", "Please check If another thread closes this channel          while the read operation is in progress for java.nio.channels.SocketChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw AsynchronousCloseException.", "Please check If another thread interrupts the current thread          while the read operation is in progress, thereby          closing the channel and setting the current thread's          interrupt status for java.nio.channels.SocketChannel.read(java.nio.ByteBuffer) in the code snippet you provided, otherwise throw ClosedByInterruptException.", "Please check If the buffer's current position is not smaller than its limit for java.nio.ByteBuffer.get() in the code snippet you provided, otherwise throw BufferUnderflowException."], "num_of_unhandled_exception": 8}
{"loop_id": 5, "unhandled_api_list": [], "num_of_unhandled_api": 0, "unhandled_exception_list": [], "num_of_unhandled_exception": 0}
