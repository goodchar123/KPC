{"loop_id": 0, "unhandled_api_list": ["java.nio.channels.AsynchronousFileChannel.lock()", "java.nio.channels.AsynchronousFileChannel.lock()"], "num_of_unhandled_api": 2, "unhandled_exception_list": ["Please check If a lock is already held by this Java virtual machine, or there          is already a pending attempt to lock a region for java.nio.channels.AsynchronousFileChannel.lock() in the code snippet you provided, otherwise throw OverlappingFileLockException.", "Please check If this channel was not opened for writing for java.nio.channels.AsynchronousFileChannel.lock() in the code snippet you provided, otherwise throw NonWritableChannelException."], "num_of_unhandled_exception": 2}
{"loop_id": 1, "unhandled_api_list": ["java.nio.channels.AsynchronousFileChannel.lock()", "java.nio.channels.AsynchronousFileChannel.lock()", "java.util.concurrent.Future.get()"], "num_of_unhandled_api": 3, "unhandled_exception_list": ["Please check If a lock is already held by this Java virtual machine, or there          is already a pending attempt to lock a region for java.nio.channels.AsynchronousFileChannel.lock() in the code snippet you provided, otherwise throw OverlappingFileLockException.", "Please check If this channel was not opened for writing for java.nio.channels.AsynchronousFileChannel.lock() in the code snippet you provided, otherwise throw NonWritableChannelException.", "Please check if the computation was cancelled for java.util.concurrent.Future.get() in the code snippet you provided, otherwise throw CancellationException."], "num_of_unhandled_exception": 3}
{"loop_id": 2, "unhandled_api_list": ["java.nio.channels.AsynchronousFileChannel.lock()", "java.nio.channels.AsynchronousFileChannel.lock()", "java.util.concurrent.Future.get()"], "num_of_unhandled_api": 3, "unhandled_exception_list": ["Please check If a lock is already held by this Java virtual machine, or there          is already a pending attempt to lock a region for java.nio.channels.AsynchronousFileChannel.lock() in the code snippet you provided, otherwise throw OverlappingFileLockException.", "Please check If this channel was not opened for writing for java.nio.channels.AsynchronousFileChannel.lock() in the code snippet you provided, otherwise throw NonWritableChannelException.", "Please check if the computation threw an exception for java.util.concurrent.Future.get() in the code snippet you provided, otherwise throw ExecutionException."], "num_of_unhandled_exception": 3}
{"loop_id": 3, "unhandled_api_list": ["java.nio.channels.AsynchronousFileChannel.lock()", "java.nio.channels.AsynchronousFileChannel.lock()", "java.util.concurrent.Future.get()"], "num_of_unhandled_api": 3, "unhandled_exception_list": ["Please check If a lock is already held by this Java virtual machine, or there          is already a pending attempt to lock a region for java.nio.channels.AsynchronousFileChannel.lock() in the code snippet you provided, otherwise throw OverlappingFileLockException.", "Please check If this channel was not opened for writing for java.nio.channels.AsynchronousFileChannel.lock() in the code snippet you provided, otherwise throw NonWritableChannelException.", "Please check if the current thread was interrupted while waiting for java.util.concurrent.Future.get() in the code snippet you provided, otherwise throw InterruptedException."], "num_of_unhandled_exception": 3}
{"loop_id": 4, "unhandled_api_list": ["java.nio.channels.AsynchronousFileChannel.open(java.nio.file.Path,java.nio.file.OpenOption...)", "java.nio.channels.AsynchronousFileChannel.open(java.nio.file.Path,java.nio.file.OpenOption...)", "java.nio.channels.AsynchronousFileChannel.open(java.nio.file.Path,java.nio.file.OpenOption...)", "java.nio.channels.AsynchronousFileChannel.open(java.nio.file.Path,java.nio.file.OpenOption...)", "java.nio.channels.AsynchronousFileChannel.open(java.nio.file.Path,java.nio.file.OpenOption...)", "java.nio.channels.AsynchronousFileChannel.lock()"], "num_of_unhandled_api": 6, "unhandled_exception_list": ["Please check If the set contains an invalid combination of options for java.nio.channels.AsynchronousFileChannel.open(java.nio.file.Path,java.nio.file.OpenOption...) in the code snippet you provided, otherwise throw IllegalArgumentException.", "Please check If the file is associated with a provider that does not          support creating file channels, or an unsupported open option is          specified for java.nio.channels.AsynchronousFileChannel.open(java.nio.file.Path,java.nio.file.OpenOption...) in the code snippet you provided, otherwise throw UnsupportedOperationException.", "Please check If a file of that name already exists and the CREATE_NEW option is specified          and the file is being opened for writing          (optional          specific exception) for java.nio.channels.AsynchronousFileChannel.open(java.nio.file.Path,java.nio.file.OpenOption...) in the code snippet you provided, otherwise throw FileAlreadyExistsException.", "Please check If an I/O error occurs for java.nio.channels.AsynchronousFileChannel.open(java.nio.file.Path,java.nio.file.OpenOption...) in the code snippet you provided, otherwise throw IOException.", "Please check If a security manager is installed and it denies an          unspecified permission required by the implementation.          In the case of the default provider, the SecurityManager.checkRead(String) method is invoked to check          read access if the file is opened for reading. The SecurityManager.checkWrite(String) method is invoked to check          write access if the file is opened for writing for java.nio.channels.AsynchronousFileChannel.open(java.nio.file.Path,java.nio.file.OpenOption...) in the code snippet you provided, otherwise throw SecurityException.", "Please check If this channel was not opened for writing for java.nio.channels.AsynchronousFileChannel.lock() in the code snippet you provided, otherwise throw NonWritableChannelException."], "num_of_unhandled_exception": 6}
{"loop_id": 5, "unhandled_api_list": [], "num_of_unhandled_api": 0, "unhandled_exception_list": [], "num_of_unhandled_exception": 0}
